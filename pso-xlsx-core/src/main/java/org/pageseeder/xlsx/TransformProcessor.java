/*
 *  Copyright (c) 2021 Allette Systems pty. ltd.
 */
package org.pageseeder.xlsx;

import org.pageseeder.xlsx.config.Param;
import org.pageseeder.xlsx.config.SplitLevel;
import org.pageseeder.xlsx.config.TransformConfig;
import org.pageseeder.xlsx.core.WorkBook;
import org.pageseeder.xlsx.core.WorkSheet;
import org.pageseeder.xlsx.interim.Interim;
import org.pageseeder.xlsx.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.transform.Templates;
import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

/**
 * Transform the XLSX (spreadsheet to an XML (PSML, etc))
 */
public class TransformProcessor {

  private static final Logger LOGGER = LoggerFactory.getLogger(TransformProcessor.class);

  private final TransformConfig _config;

  private final Writer _log;

  public TransformProcessor(TransformConfig config) {
    this(config, null);
  }

  public TransformProcessor(TransformConfig config, Writer log) {
    this._config = Objects.requireNonNull(config);
    this._log = log;
  }


  /**
   * to generate the docx.
   * @throws IOException
   */
  public void process() throws IOException {
    validateConfig();

    // Rich text support
    log("Supporting Rich Text: "+ this.getConfig().getRichtext());

    // Check ignored options
    if (this.getConfig().getSplitLevel() != SplitLevel.row) {
      if (this.getConfig().getFilenameColumn() > 0) {
        log("Setting the column filename has no effect when split level != row");
      }
    }

    // The folder and name of the presentation
    File folder = null;
    String name = null;
    if (this.getConfig().getDestination().getName().indexOf('.') > 0) {
      folder = this.getConfig().getDestination().getParentFile();
      name = this.getConfig().getDestination().getName();
      if (name.endsWith(XML.XML_EXTENSION)) name = name.substring(0, name.length()-XML.XML_EXTENSION.length());
    } else {
      folder = this.getConfig().getDestination();
      name = this.getConfig().getInput().getName();
      if (name.endsWith(".xlsx")) name = name.substring(0, name.length()-5);
    }

    // 1. Unzip file
    log("Extracting Excel Spreadsheet: " + this.getConfig().getInput().getName());
    File unpacked = new File(this.getConfig().getWorking(), "unpacked");
    unpacked.mkdir();
    ZipUtils.unzip(this.getConfig().getInput(), unpacked);

    // 2. Extract core properties
    log("Extracting Core document properties");
    CoreProperties core = CoreProperties.parse(new File(unpacked, "docProps/core.xml"));
    String title = core.title();

    // 3. Generating interim data
    log("Generating interim data");
    File interim = new File(this.getConfig().getWorking(), "interim");
    interim.mkdir();

    // TODO need to do a automatic detect in order switch between XSLT and SAX
    if (!this.getConfig().getRichtext()) {
      log("Interim will be generated by SAX, richtext will be IGNORED.");
      generateInterimBySax(unpacked, interim, this.getConfig(), title != null? title : name);
    } else {
      log("Interim will be generated by XSLT, richtext will be SUPPORTED.");
      generateInterimByXSLT(unpacked, interim, this.getConfig(), title != null? title : name);
    }

    // 4. Convert rows to PSXML
    log("Converting interim data to PSXML");
    interimToFinalXML(interim, folder, this._config, this.getConfig().getParameters() );
  }

  private void validateConfig() {
    if (this.getConfig().getInput() == null || !this.getConfig().getInput().exists()) {
      throw new IllegalArgumentException("Input XLSX is null or does not exist.");
    }

    if (this.getConfig().getWorking() == null || (this.getConfig().getWorking().exists() && !this.getConfig().getWorking().isDirectory())) {
      throw new IllegalArgumentException("if working folder exists, it must be a directory");
    }

    if (this.getConfig().getDestination() == null && !this.getConfig().getDestination().exists()) {
      throw new IllegalArgumentException("Destination is null or does not exits.");
    }

    if (this.getConfig().getSplitLevel() == null) {
      throw new IllegalArgumentException("Split level is null.");
    }

  }

  public TransformConfig getConfig() {
    return this._config;
  }

  /**
   * @return the log in string
   */
  public String getLog() {
    if (this._log != null) {
      try {
        this._log.flush();
        this._log.close();
      } catch (IOException e) {
        return "";
      }
      return this._log.toString();
    } else {
      return "";
    }
  }

  /**
   *
   * @param log
   * @throws IOException
   */
  private void log(String log) throws IOException {
    if (this._log != null) {
      this._log.append(log).append("\n");
    }
  }

  /**
   * Generate the interim files.
   *
   * @param unpacked The folder containing the unzipped workbook.
   * @param interim  The folder that should contain the interim simpler format.
   * @param config   The configuration.
   * @param title    The title of the workbook
   */
  private static void generateInterimBySax(File unpacked, File interim, TransformConfig config, String title) throws XLSXException {

    // Creates files and folders
    File xlWorkbookFolder = new File(unpacked, "/xl");
    File xlWorkbook = new File(xlWorkbookFolder, "workbook.xml");
    if (!interim.exists() && !interim.mkdirs())
      throw new XLSXException("Unable to create interim directory structure.");

    // Parse relationships
    Relationships relationships = Relationships.parse(new File(xlWorkbookFolder, "_rels/workbook.xml.rels"));

    // TODO Parse Style
    File xlStyle = new File(xlWorkbookFolder, "workbook.xml");


    try {
      // Parse shared strings
      SharedStrings shared = null;
      for (Relationship r : relationships.forType(Relationship.Type.sharedStrings)) {
        shared = SharedStrings.parse(new File(xlWorkbookFolder, r.target()));
      }

      // Parse workbook
      WorkBook workbook = WorkBook.parse(xlWorkbook, relationships);
      workbook.setTitle(title);

      // Inspect
      for (WorkSheet sheet : workbook.sheets()) {
        sheet.inspect();
      }

      // Generate the interim data
      Interim processor = new Interim(interim, config);
      processor.process(workbook, shared);

    } catch (Exception ex) {
      ex.printStackTrace();
    }
  }

  /**
   * Generate the interim files.
   *
   * @param unpacked The folder containing the unzipped workbook.
   * @param interim  The folder that should contain the interim simpler format.
   * @param config   The configuration.
   * @param title    The title of the workbook
   */
  private static void generateInterimByXSLT(File unpacked, File interim, TransformConfig config, String title) throws XLSXException {

    // Creates files and folders
    File xlFolder = new File(unpacked, "/xl");
    File xlWorkbook = new File(xlFolder, "workbook.xml");
    File itWorkbook = new File(interim, "workbook.xml");
    if (!interim.exists() && !interim.mkdirs())
      throw new XLSXException("Unable to create interim directory structure.");

    // Parse templates
    Templates templates = XSLT.getTemplatesFromResource("org/pageseeder/xlsx/xslt/split-workbook.xsl");
    String relationships = xlFolder.toURI().toString() + "_rels/workbook.xml.rels";
    String styles = xlFolder.toURI().toString() + "styles.xml";
    String outuri = interim.toURI().toString();

    // Initiate parameters
    Map<String, String> parameters = new HashMap<>();
    parameters.put("_relationships", relationships);
    parameters.put("_styles", styles);
    parameters.put("_outputfolder", outuri);
    parameters.put("_booktitle", title);
    parameters.put("_splitlevel", config.getSplitLevel().toString());
    parameters.put("_hasheaders", Boolean.toString(config.hasHeaders()));
    parameters.put("_filenamecolumn", Integer.toString(config.getFilenameColumn()));

    // Transform
    XSLT.transform(xlWorkbook, itWorkbook, templates, parameters);
  }

  /**
   * Generate the interim files.
   *
   * @param interim The folder that should contain the interim simpler format.
   * @param output  The output folder where the PSXML should be stored
   * @param config  The configuration.
   */
  private static void interimToFinalXML(File interim, File output, TransformConfig config, List<Param> params) throws XLSXException {

    // Creates files and folders
    if (!output.exists() && !output.mkdirs())
      throw new XLSXException("Unable to create output folder "+output.getName());

    // Get the templates
    Templates templates = config.getTemplates();

    // Initiate parameters
    Map<String, String> parameters = new HashMap<String, String>();
    // add parameters from the ANT task
    for (Param p : params) {
      parameters.put(p.getName(), p.getValue());
    }

    // add built in
    if (config.getRowDoctype() != null) {
      parameters.put("_rowdoctype", config.getRowDoctype());
    }

    if (config.getSheetDoctype() != null) {
      parameters.put("_sheetdoctype", config.getSheetDoctype());
    }

    if (config.getWorkbookDoctype() != null) {
      parameters.put("_workbookdoctype", config.getWorkbookDoctype());
    }

    parameters.put("_output",       output.toURI().toString());

    // Transform Workbook / WorkSheet
    for (File itf : interim.listFiles(XML.getFileFilter())) {
      File target = new File(output, itf.getName());
      XSLT.transform(itf, target, templates, parameters);
    }

    // Transform Rows
    for (File sheet : interim.listFiles(FileUtils.DIR_FILTER)) {
      File targetFolder = new File(output, sheet.getName());
      if (!targetFolder.exists()) targetFolder.mkdir();
      for (File itf : sheet.listFiles(XML.getFileFilter())) {
        File target = new File(targetFolder, itf.getName());
        XSLT.transform(itf, target, templates, parameters);
      }
    }

  }
}
